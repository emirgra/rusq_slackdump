package convertcmd

import (
	"context"
	_ "embed"
	"errors"
	"time"

	"github.com/rusq/fsadapter"

	"github.com/rusq/slackdump/v3/cmd/slackdump/internal/cfg"
	"github.com/rusq/slackdump/v3/cmd/slackdump/internal/golang/base"
	"github.com/rusq/slackdump/v3/internal/chunk"
	"github.com/rusq/slackdump/v3/internal/chunk/transform/fileproc"
	"github.com/rusq/slackdump/v3/internal/convert"
	"github.com/rusq/slackdump/v3/internal/source"
)

//go:embed assets/convert.md
var convertMd string

var CmdConvert = &base.Command{
	Run:       runConvert,
	UsageLine: "slackdump convert [flags] <source>",
	Short:     "convert slackdump chunks to various formats",
	Long: `# Convert Command
Convert slackdump archive format to various formats.

Currently only "export" format is supported.
`,
	CustomFlags: false,
	FlagMask:    cfg.OmitAll & ^cfg.OmitDownloadFlag &^ cfg.OmitOutputFlag &^ cfg.OmitDownloadAvatarsFlag,
	PrintFlags:  true,
}

type tparams struct {
	storageType fileproc.StorageType
	inputfmt    datafmt
	outputfmt   datafmt
}

var params = tparams{
	storageType: fileproc.STmattermost,
	inputfmt:    Fchunk,
	outputfmt:   Fexport,
}

func init() {
	CmdConvert.Flag.Var(&params.storageType, "storage", "storage type")
	CmdConvert.Flag.Var(&params.inputfmt, "input", "input format")
	CmdConvert.Flag.Var(&params.outputfmt, "output", "output format")
}

func runConvert(ctx context.Context, cmd *base.Command, args []string) error {
	if len(args) < 1 {
		base.SetExitStatus(base.SInvalidParameters)
		return errors.New("source and destination are required")
	}
	fn, exist := converter(params.inputfmt, params.outputfmt)
	if !exist {
		base.SetExitStatus(base.SInvalidParameters)
		return errors.New("unsupported conversion type")
	}

	lg := cfg.Log
	lg.InfoContext(ctx, "converting", "input_format", params.inputfmt, "source", args[0], "output_format", params.outputfmt, "output", cfg.Output)

	cflg := convertflags{
		withFiles:   cfg.DownloadFiles,
		withAvatars: cfg.DownloadAvatars,
		stt:         params.storageType,
	}
	start := time.Now()
	if err := fn(ctx, args[0], cfg.Output, cflg); err != nil {
		base.SetExitStatus(base.SApplicationError)
		return err
	}

	lg.InfoContext(ctx, "completed", "took", time.Since(start))
	return nil
}

func converter(input datafmt, output datafmt) (convertFunc, bool) {
	if _, ok := converters[input]; !ok {
		return nil, false
	}
	if cvt, ok := converters[input][output]; ok {
		return cvt, true
	}
	return nil, false
}

type convertFunc func(ctx context.Context, input, output string, cflg convertflags) error

// ..................input.......output..............
var converters = map[datafmt]map[datafmt]convertFunc{
	Fchunk: {
		Fexport: chunk2export,
	},
}

type convertflags struct {
	withFiles   bool
	withAvatars bool
	stt         fileproc.StorageType
}

func chunk2export(ctx context.Context, src, trg string, cflg convertflags) error {
	st, err := source.Type(src)
	if err != nil {
		return err
	}
	cd, err := chunk.OpenDir(src)
	if err != nil {
		return err
	}
	defer cd.Close()

	fsa, err := fsadapter.New(trg)
	if err != nil {
		return err
	}
	defer fsa.Close()

	sttFn, ok := fileproc.StorageTypeFuncs[cflg.stt]
	if !ok {
		return errors.New("unknown storage type")
	}

	var (
		includeFiles   = cflg.withFiles && (st&source.FMattermost != 0)
		includeAvatars = cflg.withAvatars && (st&source.FAvatars != 0)
	)

	s := source.NewChunkDir(cd, true)
	cvt := convert.NewChunkToExport(
		s,
		fsa,
		convert.WithIncludeFiles(includeFiles),
		convert.WithIncludeAvatars(includeAvatars),
		convert.WithSrcFileLoc(sttFn),
		convert.WithTrgFileLoc(sttFn),
		convert.WithLogger(cfg.Log),
	)
	if err := cvt.Convert(ctx); err != nil {
		return err
	}

	return nil
}
